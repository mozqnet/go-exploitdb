package fetcher

import (
	"bytes"
	"encoding/xml"
	"strings"

	"github.com/gocarina/gocsv"
	"github.com/inconshreveable/log15"
	"github.com/vulsio/go-exploitdb/models"
	"github.com/vulsio/go-exploitdb/util"
	"golang.org/x/net/html/charset"
	"golang.org/x/xerrors"
)

func init() {
	gocsv.SetCSVReader(gocsv.LazyCSVReader)
}

// FetchExploitDB :
func FetchExploitDB() (exploits []models.Exploit, err error) {
	var eidCvesMap map[string][]string
	if eidCvesMap, err = FetchExploitCvesMap(); err != nil {
		return nil, err
	}
	var exploitShellCodeMap map[string]models.ShellCode
	if exploitShellCodeMap, err = FetchExploitShellCodeMap(); err != nil {
		return nil, err
	}

	var exploitDocMap map[string]models.Document
	if exploitDocMap, err = FetchExploitDocumentMap(); err != nil {
		return nil, err
	}

	var exploitPaperMap map[string]models.Paper
	if exploitPaperMap, err = FetchExploitPaperMap(); err != nil {
		return nil, err
	}

	// distinct EID(nvd + github)
	uniqEIDs := map[string]struct{}{}
	for eid := range eidCvesMap {
		uniqEIDs[eid] = struct{}{}
	}
	for eid := range exploitShellCodeMap {
		uniqEIDs[eid] = struct{}{}
	}
	for eid := range exploitDocMap {
		uniqEIDs[eid] = struct{}{}
	}
	for eid := range exploitPaperMap {
		uniqEIDs[eid] = struct{}{}
	}

	for eid := range uniqEIDs {
		var description string

		paper, ok := exploitPaperMap[eid]
		if ok {
			if paper.Description != "" {
				description = paper.Description
			}
		}

		shellcode, ok := exploitShellCodeMap[eid]
		if ok {
			if shellcode.Description != "" {
				description = shellcode.Description
			}
		}

		document, ok := exploitDocMap[eid]
		if ok {
			if document.Description != "" {
				description = document.Description
			}
		}

		if len(description) == 0 {
			// 404 on exploit-db.com
			continue
		}

		cveIDs, ok := eidCvesMap[eid]
		if ok {
			for _, cveID := range cveIDs {
				exploit := models.Exploit{
					ExploitUniqueID:   eid,
					ExploitType:       models.OffensiveSecurityType,
					URL:               "https://www.exploit-db.com/exploits/" + eid,
					CveID:             cveID,
					Description:       description,
					OffensiveSecurity: reproOffensiveSecurityData(document, shellcode, paper),
				}
				exploits = append(exploits, exploit)
			}
		} else {
			exploit := models.Exploit{
				ExploitUniqueID:   eid,
				ExploitType:       models.OffensiveSecurityType,
				URL:               "https://www.exploit-db.com/exploits/" + eid,
				CveID:             "",
				Description:       description,
				OffensiveSecurity: reproOffensiveSecurityData(document, shellcode, paper),
			}
			exploits = append(exploits, exploit)
		}
	}
	return exploits, nil
}

func reproOffensiveSecurityData(document models.Document, shellcode models.ShellCode, paper models.Paper) *models.OffensiveSecurity {
	os := models.OffensiveSecurity{
		Document:  nil,
		ShellCode: nil,
		Paper:     nil,
	}

	if document.ExploitUniqueID != "" {
		os.Document = &models.Document{
			ExploitUniqueID: document.ExploitUniqueID,
			DocumentURL:     document.DocumentURL,
			Description:     document.Description,
			Date:            document.Date,
			Author:          document.Author,
			Type:            document.Type,
			Platform:        document.Platform,
			Port:            document.Port,
		}
	}

	if shellcode.ExploitUniqueID != "" {
		os.ShellCode = &models.ShellCode{
			ExploitUniqueID: shellcode.ExploitUniqueID,
			ShellCodeURL:    shellcode.ShellCodeURL,
			Description:     shellcode.Description,
			Date:            shellcode.Date,
			Author:          shellcode.Author,
			Platform:        shellcode.Platform,
		}
	}

	if paper.ExploitUniqueID != "" {
		os.Paper = &models.Paper{
			ExploitUniqueID: paper.ExploitUniqueID,
			PaperURL:        paper.PaperURL,
			Description:     paper.Description,
			Date:            paper.Date,
			Author:          paper.Author,
			Type:            paper.Type,
			Platform:        paper.Platform,
			Language:        paper.Language,
		}
	}

	return &os
}

// FetchExploitCvesMap :
func FetchExploitCvesMap() (eidCveMap map[string][]string, err error) {
	eidCveMap = map[string][]string{}
	url := "https://cve.mitre.org/data/downloads/allitems-cvrf.xml"
	log15.Info("Fetching", "URL", url)
	cveXML, err := util.FetchURL(url)
	if err != nil {
		return nil, xerrors.Errorf("Failed to fetch cve data from Mitre. targetURL: %s, err: %w", url, err)
	}

	var mitreCve models.MitreXML
	// https://stackoverflow.com/questions/6002619/unmarshal-an-iso-8859-1-xml-input-in-go
	decoder := xml.NewDecoder(bytes.NewReader(cveXML))
	decoder.CharsetReader = charset.NewReaderLabel
	if err = decoder.Decode(&mitreCve); err != nil {
		return nil, xerrors.Errorf("Failed to Unmarshal XML. URL: %s, err: %w", url, err)
	}
	for _, vuln := range mitreCve.Vulnerability {
		for _, ref := range vuln.References {
			if strings.HasPrefix(ref.URL, "https://www.exploit-db.com/exploits/") {
				eid := strings.TrimSuffix(strings.TrimPrefix(ref.URL, "https://www.exploit-db.com/exploits/"), "/")
				eidCveMap[eid] = append(eidCveMap[eid], vuln.CVE)
				continue
			}

			ss := strings.Split(ref.Description, ":")
			if len(ss) != 2 {
				continue
			}
			refType, exploitID := ss[0], ss[1]
			// https://cve.mitre.org/data/refs/index.html
			if refType != "EXPLOIT-DB" {
				continue
			}
			eidCveMap[exploitID] = append(eidCveMap[exploitID], vuln.CVE)
		}
	}

	return eidCveMap, nil
}

// FetchExploitShellCodeMap :
func FetchExploitShellCodeMap() (eidShellCodeMap map[string]models.ShellCode, err error) {
	eidShellCodeMap = map[string]models.ShellCode{}
	url := "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_shellcodes.csv"
	log15.Info("Fetching", "URL", url)
	cveCsv, err := util.FetchURL(url)
	if err != nil {
		return nil, err
	}
	shellCodes := []models.ShellCode{}
	if err := gocsv.UnmarshalBytes(cveCsv, &shellCodes); err != nil {
		return nil, err
	}

	for _, shellCode := range shellCodes {
		shellCode.ShellCodeURL = "https://gitlab.com/exploit-database/exploitdb/-/blob/main/" + shellCode.ShellCodeURL
		eidShellCodeMap[shellCode.ExploitUniqueID] = shellCode
	}
	return eidShellCodeMap, nil
}

// FetchExploitDocumentMap :
func FetchExploitDocumentMap() (eidDocMap map[string]models.Document, err error) {
	eidDocMap = map[string]models.Document{}
	url := "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"
	log15.Info("Fetching", "URL", url)
	cveCsv, err := util.FetchURL(url)
	if err != nil {
		return nil, err
	}
	docs := []models.Document{}
	if err := gocsv.UnmarshalBytes(cveCsv, &docs); err != nil {
		return nil, err
	}

	for _, doc := range docs {
		doc.DocumentURL = "https://gitlab.com/exploit-database/exploitdb/-/blob/main/" + doc.DocumentURL
		eidDocMap[doc.ExploitUniqueID] = doc
	}
	return eidDocMap, nil
}

// FetchExploitPaperMap :
func FetchExploitPaperMap() (eidPaperMap map[string]models.Paper, err error) {
	eidPaperMap = map[string]models.Paper{}
	url := "https://gitlab.com/exploit-database/exploitdb-papers/-/raw/main/files_papers.csv"
	log15.Info("Fetching", "URL", url)
	cveCsv, err := util.FetchURL(url)
	if err != nil {
		return nil, err
	}
	papers := []models.Paper{}
	if err := gocsv.UnmarshalBytes(cveCsv, &papers); err != nil {
		return nil, err
	}

	for _, paper := range papers {
		paper.PaperURL = "https://gitlab.com/exploit-database/exploitdb/-/blob/main/" + paper.PaperURL
		eidPaperMap[paper.ExploitUniqueID] = paper
	}
	return eidPaperMap, nil
}
