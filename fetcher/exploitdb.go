package fetcher

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"path/filepath"
	"strings"
	"time"

	"github.com/cheggaaa/pb/v3"
	"github.com/gocarina/gocsv"
	"github.com/inconshreveable/log15"
	"github.com/pkg/errors"
	"github.com/vulsio/go-exploitdb/extractor"
	"github.com/vulsio/go-exploitdb/models"
	"github.com/vulsio/go-exploitdb/util"
	"golang.org/x/net/html/charset"
)

// FetchExploitDB :
func FetchExploitDB(deep bool) (exploits []models.Exploit, err error) {
	var eidCvesMap map[string][]string
	if eidCvesMap, err = FetchExploitCvesMap(deep); err != nil {
		return nil, err
	}
	var exploitShellCodeMap map[string]models.ShellCode
	if exploitShellCodeMap, err = FetchExploitShellCodeMap(); err != nil {
		return nil, err
	}

	var exploitDocMap map[string]models.Document
	if exploitDocMap, err = FetchExploitDocumentMap(); err != nil {
		return nil, err
	}

	// distinct EID(nvd + github)
	uniqEIDs := map[string]struct{}{}
	for eid := range eidCvesMap {
		uniqEIDs[eid] = struct{}{}
	}
	for eid := range exploitShellCodeMap {
		uniqEIDs[eid] = struct{}{}
	}
	for eid := range exploitDocMap {
		uniqEIDs[eid] = struct{}{}
	}

	for eid := range uniqEIDs {
		cveIDs, ok := eidCvesMap[eid]
		if ok {
			for _, cveID := range cveIDs {
				var description string
				if e, ok := exploitShellCodeMap[eid]; ok {
					description = e.Description
				}
				if e, ok := exploitDocMap[eid]; ok {
					description = e.Description
				}
				if len(description) == 0 {
					// 404 on exploit-db.com
					continue
				}
				exploit := models.Exploit{
					ExploitUniqueID: eid,
					ExploitType:     models.OffensiveSecurityType,
					URL:             "https://www.exploit-db.com/exploits/" + eid,
					CveID:           cveID,
					Description:     description,
					OffensiveSecurity: models.OffensiveSecurity{
						ExploitUniqueID: eid,
						Document:        exploitDocMap[eid],
						ShellCode:       exploitShellCodeMap[eid],
					},
				}
				exploits = append(exploits, exploit)
			}
		} else {
			// No CveID
			var description string
			if e, ok := exploitShellCodeMap[eid]; ok {
				description = e.Description
			}
			if e, ok := exploitDocMap[eid]; ok {
				description = e.Description
			}
			if len(description) == 0 {
				continue
			}
			exploit := models.Exploit{
				ExploitUniqueID: eid,
				ExploitType:     models.OffensiveSecurityType,
				URL:             "https://www.exploit-db.com/exploits/" + eid,
				Description:     description,
				OffensiveSecurity: models.OffensiveSecurity{
					Document:  exploitDocMap[eid],
					ShellCode: exploitShellCodeMap[eid],
				},
			}
			exploits = append(exploits, exploit)
		}
	}
	return exploits, nil
}

// FetchExploitCvesMap :
func FetchExploitCvesMap(deep bool) (eidCveMap map[string][]string, err error) {
	eidCveMap = map[string][]string{}
	url := fmt.Sprintf("https://cve.mitre.org/data/downloads/allitems-cvrf.xml")
	log15.Info("Fetching", "URL", url)
	cveXML, err := util.FetchURL(url)
	if err != nil {
		return nil,
			errors.Wrapf(err, "Failed to fetch cve data from Mitre. targetURL: %s", url)
	}

	var mitreCve models.MitreXML
	// https://stackoverflow.com/questions/6002619/unmarshal-an-iso-8859-1-xml-input-in-go
	decoder := xml.NewDecoder(bytes.NewReader(cveXML))
	decoder.CharsetReader = charset.NewReaderLabel
	if err = decoder.Decode(&mitreCve); err != nil {
		return nil, fmt.Errorf("Failed to Unmarshal XML. URL: %s, err: %s", url, err)
	}
	for _, vuln := range mitreCve.Vulnerability {
		for _, ref := range vuln.References {
			if strings.HasPrefix(ref.URL, "https://www.exploit-db.com/exploits/") {
				eid := strings.TrimSuffix(strings.TrimPrefix(ref.URL, "https://www.exploit-db.com/exploits/"), "/")
				eidCveMap[eid] = append(eidCveMap[eid], vuln.CVE)
				continue
			}

			ss := strings.Split(ref.Description, ":")
			if len(ss) != 2 {
				continue
			}
			refType, exploitID := ss[0], ss[1]
			// https://cve.mitre.org/data/refs/index.html
			if refType != "EXPLOIT-DB" {
				continue
			}
			eidCveMap[exploitID] = append(eidCveMap[exploitID], vuln.CVE)
		}
	}

	if !deep {
		return eidCveMap, nil
	}

	// https://github.com/offensive-security/exploitdb/search?q=CVE&unscoped_q=CVE
	// over 500 count
	heavyExts := []string{
		"txt",
		"rb",
		"py",
	}
	// under 500 count
	lightExts := []string{
		"c",
		"html",
		"pl",
		"pm",
		"sh",
		"md",
		"php",
		"cpp",
		"java",
		"go",
		"cs",
		"nse",
		"asm",
		"sql",
	}

	for year := 1999; year <= time.Now().Year(); year++ {
		log15.Info("Fetching GitHub Sources", "year", year)
		if eidCveMap, err = SearchGitHubCodeWithExt(heavyExts, year, eidCveMap); err != nil {
			return nil, err
		}
	}
	if eidCveMap, err = SearchGitHubCodeWithExt(lightExts, 0, eidCveMap); err != nil {
		return nil, err
	}
	return eidCveMap, nil
}

// SearchGitHubCodeWithExt :
func SearchGitHubCodeWithExt(exts []string, year int, exploitCveMap map[string][]string) (newExploitCveMap map[string][]string, err error) {
	if exploitCveMap == nil {
		exploitCveMap = map[string][]string{}
	}
	for _, ext := range exts {
		page := 1
		// max request of search code is 1000
		maxPage := 10
		for {
			if maxPage < page {
				break
			}
			// https://developer.github.com/v3/search/#search-code
			var url string
			if year == 0 {
				url = fmt.Sprintf("https://api.github.com/search/code?q=CVE+extension:%s+repo:offensive-security/exploitdb&page=%d&per_page=100&sort=indexed&order=desc", ext, page)
			} else {
				spaceCode := "%20"
				url = fmt.Sprintf("https://api.github.com/search/code?q=CVE%s%d+extension:%s+repo:offensive-security/exploitdb&page=%d&per_page=100&sort=indexed&order=desc", spaceCode, year, ext, page)
			}
			log15.Info("Fetching", "URL", url)
			githubJSON, err := util.FetchURL(url)
			if err != nil {
				log15.Warn("Failed to fetch cve data from GitHub.", "url", url)
				break
			}
			var github models.GitHubJSON
			if err = json.Unmarshal(githubJSON, &github); err != nil {
				return nil, err
			}
			bar := pb.StartNew(len(github.Items))
			// for github rate limit
			if 1000 < len(github.Items) {
				log15.Warn("More than 1000 data can not be acquired due to rate limit of github")
			}
			for _, item := range github.Items {
				path := "https://raw.githubusercontent.com/offensive-security/exploitdb/master/" + item.Path
				exploitDBID := strings.TrimSuffix(filepath.Base(path), filepath.Ext(path))
				if _, ok := exploitCveMap[exploitDBID]; !ok {
					doc, err := util.FetchURL(path)
					if err != nil {
						return nil, err
					}
					exploitCveMap[exploitDBID] = extractor.ExtractCveID(doc)
				}
				bar.Increment()
			}
			bar.Finish()
			if page == 1 {
				totalPageSize := (github.TotalCount / 100) + 1
				if totalPageSize < maxPage {
					maxPage = totalPageSize
				}
			}
			page++
		}
	}
	return exploitCveMap, nil
}

// FetchExploitShellCodeMap :
func FetchExploitShellCodeMap() (eidShellCodeMap map[string]models.ShellCode, err error) {
	eidShellCodeMap = map[string]models.ShellCode{}
	url := "https://raw.githubusercontent.com/offensive-security/exploitdb/master/files_shellcodes.csv"
	log15.Info("Fetching", "URL", url)
	cveCsv, err := util.FetchURL(url)
	if err != nil {
		return nil, err
	}
	shellCodes := []models.ShellCode{}
	if err := gocsv.UnmarshalBytes(cveCsv, &shellCodes); err != nil {
		return nil, err
	}

	for _, shellCode := range shellCodes {
		shellCode.ShellCodeURL = "https://github.com/offensive-security/exploitdb/" + shellCode.ShellCodeURL
		eidShellCodeMap[shellCode.ExploitUniqueID] = shellCode
	}
	return eidShellCodeMap, nil
}

// FetchExploitDocumentMap :
func FetchExploitDocumentMap() (eidDocMap map[string]models.Document, err error) {
	eidDocMap = map[string]models.Document{}
	url := "https://raw.githubusercontent.com/offensive-security/exploitdb/master/files_exploits.csv"
	log15.Info("Fetching", "URL", url)
	cveCsv, err := util.FetchURL(url)
	if err != nil {
		return nil, err
	}
	docs := []models.Document{}
	if err := gocsv.UnmarshalBytes(cveCsv, &docs); err != nil {
		return nil, err
	}

	for _, doc := range docs {
		doc.DocumentURL = "https://github.com/offensive-security/exploitdb/" + doc.DocumentURL
		eidDocMap[doc.ExploitUniqueID] = doc
	}
	return eidDocMap, nil
}
