package fetcher

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"net/url"
	"path"
	"strconv"
	"strings"
	"time"

	"github.com/gocarina/gocsv"
	"github.com/inconshreveable/log15"
	"golang.org/x/net/html/charset"
	"golang.org/x/xerrors"

	"github.com/vulsio/go-exploitdb/models"
	"github.com/vulsio/go-exploitdb/util"
)

// FetchExploitDB :
func FetchExploitDB() ([]models.Exploit, error) {
	toCVEs, err := fetchExploitMitreCVE()
	if err != nil {
		return nil, xerrors.Errorf("Failed to fetch mitre cve. err: %w", err)
	}

	toDocument, err := fetchExploitDocument()
	if err != nil {
		return nil, xerrors.Errorf("Failed to fetch document. err: %w", err)
	}

	toShellCode, err := fetchExploitShellCode()
	if err != nil {
		return nil, xerrors.Errorf("Failed to fetch shellcode. err: %w", err)
	}

	toPaper, err := fetchExploitPaper()
	if err != nil {
		return nil, xerrors.Errorf("Failed to fetch paper. err: %w", err)
	}

	toGHDB, err := fetchExploitGHDB()
	if err != nil {
		return nil, xerrors.Errorf("Failed to fetch ghdb. err: %w", err)
	}

	return joinExploits(toCVEs, toDocument, toShellCode, toPaper, toGHDB), nil
}

type cvrfdoc struct {
	Vulnerability []struct {
		CVE        string `xml:"CVE"`
		References []struct {
			URL         string `xml:"URL"`
			Description string `xml:"Description"`
		} `xml:"References>Reference"`
	} `xml:"Vulnerability"`
}

func fetchExploitMitreCVE() (map[string][]string, error) {
	url := "https://cve.mitre.org/data/downloads/allitems-cvrf.xml"
	log15.Info("Fetching", "URL", url)
	bs, err := util.FetchURL(url)
	if err != nil {
		return nil, xerrors.Errorf("Failed to fetch. err: %w", err)
	}

	var root cvrfdoc
	decoder := xml.NewDecoder(bytes.NewReader(bs))
	decoder.CharsetReader = charset.NewReaderLabel
	if err = decoder.Decode(&root); err != nil {
		return nil, xerrors.Errorf("Failed to unmarshal. err: %w", err)
	}

	toCVEs := map[string][]string{}
	for _, e := range root.Vulnerability {
		for _, r := range e.References {
			if strings.HasPrefix(r.URL, "https://www.exploit-db.com/exploits/") {
				eid := strings.TrimSuffix(strings.TrimPrefix(r.URL, "https://www.exploit-db.com/exploits/"), "/")
				toCVEs[eid] = append(toCVEs[eid], e.CVE)
				continue
			}

			refType, exploitID, ok := strings.Cut(r.Description, ":")
			if !ok {
				continue
			}
			// https://cve.mitre.org/data/refs/index.html
			if refType != "EXPLOIT-DB" {
				continue
			}
			if _, err := strconv.Atoi(exploitID); err != nil {
				continue
			}
			toCVEs[exploitID] = append(toCVEs[exploitID], e.CVE)
		}
	}
	return toCVEs, nil
}

type document struct {
	ID             string `csv:"id"`
	File           string `csv:"file"`
	Description    string `csv:"description"`
	DatePublished  string `csv:"date_published"`
	Author         string `csv:"author"`
	Type           string `csv:"type"`
	Platform       string `csv:"platform"`
	Port           string `csv:"port"`
	DateAdded      string `csv:"date_added"`
	DateUpdated    string `csv:"date_updated"`
	Verified       string `csv:"verified"`
	Codes          string `csv:"codes"`
	Tags           string `csv:"tags"`
	Aliases        string `csv:"aliases"`
	ScreenshotURL  string `csv:"screenshot_url"`
	ApplicationURL string `csv:"application_url"`
	SourceURL      string `csv:"source_url"`
}

func fetchExploitDocument() (map[string]models.Document, error) {
	url := "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"
	log15.Info("Fetching", "URL", url)
	bs, err := util.FetchURL(url)
	if err != nil {
		return nil, xerrors.Errorf("Failed to fetch. err: %w", err)
	}

	var entries []document
	if err := gocsv.UnmarshalBytes(bs, &entries); err != nil {
		return nil, xerrors.Errorf("Failed to unmarshal. err: %w", err)
	}

	toDocument := map[string]models.Document{}
	for _, e := range entries {
		verified, err := strconv.ParseBool(e.Verified)
		if err != nil {
			log15.Warn("Failed to parse verified to bool", "verified", e.Verified)
		}

		toDocument[e.ID] = models.Document{
			Base: models.Base{
				FileURL:        fmt.Sprintf("https://gitlab.com/exploit-database/exploitdb/-/blob/main/%s", e.File),
				Description:    e.Description,
				DatePublished:  parseDate(e.DatePublished),
				Author:         e.Author,
				Type:           e.Type,
				Platform:       e.Platform,
				DateAdded:      parseDate(e.DateAdded),
				DateUpdated:    parseDate(e.DateUpdated),
				Verified:       verified,
				Codes:          e.Codes,
				Tags:           e.Tags,
				Aliases:        e.Aliases,
				ScreenshotURL:  e.ScreenshotURL,
				ApplicationURL: e.ApplicationURL,
				SourceURL:      e.SourceURL,
			},
			Port: e.Port,
		}
	}
	return toDocument, nil
}

type shellcode struct {
	ID             string `csv:"id"`
	File           string `csv:"file"`
	Description    string `csv:"description"`
	DatePublished  string `csv:"date_published"`
	Author         string `csv:"author"`
	Type           string `csv:"type"`
	Platform       string `csv:"platform"`
	Size           string `csv:"size"`
	DateAdded      string `csv:"date_added"`
	DateUpdated    string `csv:"date_updated"`
	Verified       string `csv:"verified"`
	Codes          string `csv:"codes"`
	Tags           string `csv:"tags"`
	Aliases        string `csv:"aliases"`
	ScreenshotURL  string `csv:"screenshot_url"`
	ApplicationURL string `csv:"application_url"`
	SourceURL      string `csv:"source_url"`
}

func fetchExploitShellCode() (map[string]models.ShellCode, error) {
	url := "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_shellcodes.csv"
	log15.Info("Fetching", "URL", url)
	bs, err := util.FetchURL(url)
	if err != nil {
		return nil, xerrors.Errorf("Failed to fetch. err: %w", err)
	}

	var entries []shellcode
	if err := gocsv.UnmarshalBytes(bs, &entries); err != nil {
		return nil, xerrors.Errorf("Failed to unmarshal. err: %w", err)
	}

	toShellCode := map[string]models.ShellCode{}
	for _, e := range entries {
		verified, err := strconv.ParseBool(e.Verified)
		if err != nil {
			log15.Warn("Failed to parse verified to bool", "verified", e.Verified)
			verified = false
		}

		toShellCode[e.ID] = models.ShellCode{
			Base: models.Base{
				FileURL:        fmt.Sprintf("https://gitlab.com/exploit-database/exploitdb/-/blob/main/%s", e.File),
				Description:    e.Description,
				DatePublished:  parseDate(e.DatePublished),
				Author:         e.Author,
				Type:           e.Type,
				Platform:       e.Platform,
				DateAdded:      parseDate(e.DateAdded),
				DateUpdated:    parseDate(e.DateUpdated),
				Verified:       verified,
				Codes:          e.Codes,
				Tags:           e.Tags,
				Aliases:        e.Aliases,
				ScreenshotURL:  e.ScreenshotURL,
				ApplicationURL: e.ApplicationURL,
				SourceURL:      e.SourceURL,
			},
			Size: e.Size,
		}
	}
	return toShellCode, nil
}

type paper struct {
	ID             string `csv:"id"`
	File           string `csv:"file"`
	Description    string `csv:"description"`
	DatePublished  string `csv:"date_published"`
	Author         string `csv:"author"`
	Type           string `csv:"type"`
	Platform       string `csv:"platform"`
	Language       string `csv:"language"`
	DateAdded      string `csv:"date_added"`
	DateUpdated    string `csv:"date_updated"`
	Verified       string `csv:"verified"`
	Codes          string `csv:"codes"`
	Tags           string `csv:"tags"`
	Aliases        string `csv:"aliases"`
	ScreenshotURL  string `csv:"screenshot_url"`
	ApplicationURL string `csv:"application_url"`
	SourceURL      string `csv:"source_url"`
}

func fetchExploitPaper() (map[string]models.Paper, error) {
	url := "https://gitlab.com/exploit-database/exploitdb-papers/-/raw/main/files_papers.csv"
	log15.Info("Fetching", "URL", url)
	bs, err := util.FetchURL(url)
	if err != nil {
		return nil, xerrors.Errorf("Failed to fetch. err: %w", err)
	}

	var entries []paper
	if err := gocsv.UnmarshalBytes(bs, &entries); err != nil {
		return nil, xerrors.Errorf("Failed to unmarshal. err: %w", err)
	}

	toPaper := map[string]models.Paper{}
	for _, e := range entries {
		verified, err := strconv.ParseBool(e.Verified)
		if err != nil {
			log15.Warn("Failed to parse verified to bool", "verified", e.Verified)
			verified = false
		}

		toPaper[e.ID] = models.Paper{
			Base: models.Base{
				FileURL:        fmt.Sprintf("https://gitlab.com/exploit-database/exploitdb-papers/-/blob/main/%s", e.File),
				Description:    e.Description,
				DatePublished:  parseDate(e.DatePublished),
				Author:         e.Author,
				Type:           e.Type,
				Platform:       e.Platform,
				DateAdded:      parseDate(e.DateAdded),
				DateUpdated:    parseDate(e.DateUpdated),
				Verified:       verified,
				Codes:          e.Codes,
				Tags:           e.Tags,
				Aliases:        e.Aliases,
				ScreenshotURL:  e.ScreenshotURL,
				ApplicationURL: e.ApplicationURL,
				SourceURL:      e.SourceURL,
			},
			Language: e.Language,
		}
	}
	return toPaper, nil
}

type ghdb struct {
	Entry []struct {
		ID                 string `xml:"id"`
		Link               string `xml:"link"`
		Category           string `xml:"category"`
		ShortDescription   string `xml:"shortDescription"`
		TextualDescription string `xml:"textualDescription"`
		Query              string `xml:"query"`
		Querystring        string `xml:"querystring"`
		Edb                string `xml:"edb"`
		Date               string `xml:"date"`
		Author             string `xml:"author"`
	} `xml:"entry"`
}

func fetchExploitGHDB() (map[string]models.GHDB, error) {
	url := "https://gitlab.com/exploit-database/exploitdb/-/raw/main/ghdb.xml"
	log15.Info("Fetching", "URL", url)
	bs, err := util.FetchURL(url)
	if err != nil {
		return nil, xerrors.Errorf("Failed to fetch. err: %w", err)
	}

	var ghdb ghdb
	if err := xml.Unmarshal(bs, &ghdb); err != nil {
		return nil, xerrors.Errorf("Failed to unmarshal. err: %w", err)
	}

	toGHDB := map[string]models.GHDB{}
	for _, e := range ghdb.Entry {
		toGHDB[e.ID] = models.GHDB{
			Link:               e.Link,
			Category:           e.Category,
			ShortDescription:   e.ShortDescription,
			TextualDescription: e.TextualDescription,
			Query:              e.Query,
			Querystring:        e.Querystring,
			Edb:                e.Edb,
			Date:               parseDate(e.Date),
			Author:             e.Author,
		}
	}
	return toGHDB, nil
}

func parseDate(datestr string) *time.Time {
	t, err := time.Parse("2006-01-02", datestr)
	if err != nil {
		return nil
	}
	return &t
}

func joinExploits(toCVEs map[string][]string, toDocument map[string]models.Document, toShellCode map[string]models.ShellCode, toPaper map[string]models.Paper, toGHDB map[string]models.GHDB) []models.Exploit {
	toExploits := map[string][]models.Exploit{}

	for id, e := range toDocument {
		cves := toCVEs[id]
		for _, code := range strings.Split(e.Codes, ";") {
			if !strings.HasPrefix(code, "CVE-") {
				continue
			}
			cves = append(cves, code)
		}
		toCVEs[id] = util.Unique(cves)
	}
	for id, e := range toShellCode {
		cves := toCVEs[id]
		for _, code := range strings.Split(e.Codes, ";") {
			if !strings.HasPrefix(code, "CVE-") {
				continue
			}
			cves = append(cves, code)
		}
		toCVEs[id] = util.Unique(cves)
	}
	for id, e := range toPaper {
		cves := toCVEs[id]
		for _, code := range strings.Split(e.Codes, ";") {
			if !strings.HasPrefix(code, "CVE-") {
				continue
			}
			cves = append(cves, code)
		}
		toCVEs[id] = util.Unique(cves)
	}

	for id, cves := range toCVEs {
		if len(cves) > 0 {
			for _, cve := range cves {
				toExploits[id] = append(toExploits[id], models.Exploit{
					ExploitType:       models.OffensiveSecurityType,
					ExploitUniqueID:   id,
					URL:               fmt.Sprintf("https://www.exploit-db.com/exploits/%s", id),
					CveID:             cve,
					OffensiveSecurity: &models.OffensiveSecurity{},
				})
			}
		} else {
			toExploits[id] = append(toExploits[id], models.Exploit{
				ExploitType:       models.OffensiveSecurityType,
				ExploitUniqueID:   id,
				URL:               fmt.Sprintf("https://www.exploit-db.com/exploits/%s", id),
				OffensiveSecurity: &models.OffensiveSecurity{},
			})
		}
	}

	for id, d := range toDocument {
		es := make([]models.Exploit, 0, len(toExploits[id]))
		for _, e := range toExploits[id] {
			es = append(es, models.Exploit{
				ExploitType:     models.OffensiveSecurityType,
				ExploitUniqueID: id,
				URL:             fmt.Sprintf("https://www.exploit-db.com/exploits/%s", id),
				Description:     d.Description,
				CveID:           e.CveID,
				OffensiveSecurity: &models.OffensiveSecurity{
					Document: &models.Document{
						Base: models.Base{
							FileURL:        d.FileURL,
							Description:    d.Description,
							DatePublished:  d.DatePublished,
							Author:         d.Author,
							Type:           d.Type,
							Platform:       d.Platform,
							DateAdded:      d.DateAdded,
							DateUpdated:    d.DateUpdated,
							Verified:       d.Verified,
							Codes:          d.Codes,
							Tags:           d.Tags,
							Aliases:        d.Aliases,
							ScreenshotURL:  d.ScreenshotURL,
							ApplicationURL: d.ApplicationURL,
							SourceURL:      d.SourceURL,
						},
						Port: d.Port,
					},
				},
			})
		}
		toExploits[id] = es
	}

	for id, sc := range toShellCode {
		es := make([]models.Exploit, 0, len(toExploits[id]))
		for _, e := range toExploits[id] {
			es = append(es, models.Exploit{
				ExploitType:     models.OffensiveSecurityType,
				ExploitUniqueID: id,
				URL:             fmt.Sprintf("https://www.exploit-db.com/shellcodes/%s", id),
				Description:     sc.Description,
				CveID:           e.CveID,
				OffensiveSecurity: &models.OffensiveSecurity{
					ShellCode: &models.ShellCode{
						Base: models.Base{
							FileURL:        sc.FileURL,
							Description:    sc.Description,
							DatePublished:  sc.DatePublished,
							Author:         sc.Author,
							Type:           sc.Type,
							Platform:       sc.Platform,
							DateAdded:      sc.DateAdded,
							DateUpdated:    sc.DateUpdated,
							Verified:       sc.Verified,
							Codes:          sc.Codes,
							Tags:           sc.Tags,
							Aliases:        sc.Aliases,
							ScreenshotURL:  sc.ScreenshotURL,
							ApplicationURL: sc.ApplicationURL,
							SourceURL:      sc.SourceURL,
						},
						Size: sc.Size,
					},
				},
			})
		}
		toExploits[id] = es
	}

	for id, p := range toPaper {
		u := fmt.Sprintf("https://www.exploit-db.com/docs/%s", id)
		if strings.HasPrefix(p.FileURL, "https://gitlab.com/exploit-database/exploitdb-papers/-/blob/main/papers") {
			u = fmt.Sprintf("https://www.exploit-db.com/papers/%s", id)
		}

		es := make([]models.Exploit, 0, len(toExploits[id]))
		for _, e := range toExploits[id] {
			es = append(es, models.Exploit{
				ExploitType:     models.OffensiveSecurityType,
				ExploitUniqueID: id,
				URL:             u,
				Description:     p.Description,
				CveID:           e.CveID,
				OffensiveSecurity: &models.OffensiveSecurity{
					Paper: &models.Paper{
						Base: models.Base{
							FileURL:        p.FileURL,
							Description:    p.Description,
							DatePublished:  p.DatePublished,
							Author:         p.Author,
							Type:           p.Type,
							Platform:       p.Platform,
							DateAdded:      p.DateAdded,
							DateUpdated:    p.DateUpdated,
							Verified:       p.Verified,
							Codes:          p.Codes,
							Tags:           p.Tags,
							Aliases:        p.Aliases,
							ScreenshotURL:  p.ScreenshotURL,
							ApplicationURL: p.ApplicationURL,
							SourceURL:      p.SourceURL,
						},
						Language: p.Language,
					},
				},
			})
		}
		toExploits[id] = es
	}

	for id, ghdb := range toGHDB {
		ghdbID := fmt.Sprintf("GHDB-%s", id)
		toExploits[ghdbID] = append(toExploits[ghdbID], models.Exploit{
			ExploitType:     models.OffensiveSecurityType,
			ExploitUniqueID: ghdbID,
			URL:             fmt.Sprintf("https://www.exploit-db.com/ghdb/%s", id),
			Description:     ghdb.ShortDescription,
			OffensiveSecurity: &models.OffensiveSecurity{
				GHDB: &models.GHDB{
					Link:               ghdb.Link,
					Category:           ghdb.Category,
					ShortDescription:   ghdb.ShortDescription,
					TextualDescription: ghdb.TextualDescription,
					Query:              ghdb.Query,
					Querystring:        ghdb.Querystring,
					Edb:                ghdb.Edb,
					Date:               ghdb.Date,
					Author:             ghdb.Author,
				},
			},
		})

		if ghdb.Edb == "" {
			continue
		}
		u, err := url.Parse(ghdb.Edb)
		if err != nil {
			continue
		}
		eid := path.Base(u.Path)
		es, ok := toExploits[eid]
		if !ok {
			continue
		}
		for i := range es {
			es[i].OffensiveSecurity.GHDB = &models.GHDB{
				Link:               ghdb.Link,
				Category:           ghdb.Category,
				ShortDescription:   ghdb.ShortDescription,
				TextualDescription: ghdb.TextualDescription,
				Query:              ghdb.Query,
				Querystring:        ghdb.Querystring,
				Edb:                ghdb.Edb,
				Date:               ghdb.Date,
				Author:             ghdb.Author,
			}
		}
		toExploits[eid] = es
	}

	var exploits []models.Exploit
	for _, es := range toExploits {
		exploits = append(exploits, es...)
	}
	return exploits
}
