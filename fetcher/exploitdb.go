package fetcher

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"strings"

	"github.com/gocarina/gocsv"
	"github.com/inconshreveable/log15"
	"github.com/pkg/errors"
	"github.com/vulsio/go-exploitdb/models"
	"github.com/vulsio/go-exploitdb/util"
	"golang.org/x/net/html/charset"
)

// FetchExploitDB :
func FetchExploitDB() (exploits []models.Exploit, err error) {
	var eidCvesMap map[string][]string
	if eidCvesMap, err = FetchExploitCvesMap(); err != nil {
		return nil, err
	}
	var exploitShellCodeMap map[string]models.ShellCode
	if exploitShellCodeMap, err = FetchExploitShellCodeMap(); err != nil {
		return nil, err
	}

	var exploitDocMap map[string]models.Document
	if exploitDocMap, err = FetchExploitDocumentMap(); err != nil {
		return nil, err
	}

	var exploitPaperMap map[string]models.Paper
	if exploitPaperMap, err = FetchExploitPaperMap(); err != nil {
		return nil, err
	}

	// distinct EID(nvd + github)
	uniqEIDs := map[string]struct{}{}
	for eid := range eidCvesMap {
		uniqEIDs[eid] = struct{}{}
	}
	for eid := range exploitShellCodeMap {
		uniqEIDs[eid] = struct{}{}
	}
	for eid := range exploitDocMap {
		uniqEIDs[eid] = struct{}{}
	}
	for eid := range exploitPaperMap {
		uniqEIDs[eid] = struct{}{}
	}

	for eid := range uniqEIDs {
		cveIDs, ok := eidCvesMap[eid]
		if ok {
			for _, cveID := range cveIDs {
				var description string
				if e, ok := exploitPaperMap[eid]; ok {
					description = e.Description
				}
				if e, ok := exploitShellCodeMap[eid]; ok {
					description = e.Description
				}
				if e, ok := exploitDocMap[eid]; ok {
					description = e.Description
				}
				if len(description) == 0 {
					// 404 on exploit-db.com
					continue
				}
				document := exploitDocMap[eid]
				shellcode := exploitShellCodeMap[eid]

				exploit := models.Exploit{
					ExploitUniqueID: eid,
					ExploitType:     models.OffensiveSecurityType,
					URL:             "https://www.exploit-db.com/exploits/" + eid,
					CveID:           cveID,
					Description:     description,
					OffensiveSecurity: &models.OffensiveSecurity{
						ExploitUniqueID: eid,
						Document:        exploitDocMap[eid],
						ShellCode:       exploitShellCodeMap[eid],
						Paper:           exploitPaperMap[eid],
					},
				}
				exploits = append(exploits, exploit)
			}
		} else {
			// No CveID
			var description string
			if e, ok := exploitPaperMap[eid]; ok {
				description = e.Description
			}
			if e, ok := exploitShellCodeMap[eid]; ok {
				description = e.Description
			}
			if e, ok := exploitDocMap[eid]; ok {
				description = e.Description
			}
			if len(description) == 0 {
				continue
			}
			document := exploitDocMap[eid]
			shellcode := exploitShellCodeMap[eid]

			exploit := models.Exploit{
				ExploitUniqueID: eid,
				ExploitType:     models.OffensiveSecurityType,
				URL:             "https://www.exploit-db.com/exploits/" + eid,
				Description:     description,
				OffensiveSecurity: &models.OffensiveSecurity{
					ExploitUniqueID: eid,
					Document:        exploitDocMap[eid],
					ShellCode:       exploitShellCodeMap[eid],
					Paper:           exploitPaperMap[eid],
				},
			}
			exploits = append(exploits, exploit)
		}
	}
	return exploits, nil
}

// FetchExploitCvesMap :
func FetchExploitCvesMap() (eidCveMap map[string][]string, err error) {
	eidCveMap = map[string][]string{}
	url := "https://cve.mitre.org/data/downloads/allitems-cvrf.xml"
	log15.Info("Fetching", "URL", url)
	cveXML, err := util.FetchURL(url)
	if err != nil {
		return nil,
			errors.Wrapf(err, "Failed to fetch cve data from Mitre. targetURL: %s", url)
	}

	var mitreCve models.MitreXML
	// https://stackoverflow.com/questions/6002619/unmarshal-an-iso-8859-1-xml-input-in-go
	decoder := xml.NewDecoder(bytes.NewReader(cveXML))
	decoder.CharsetReader = charset.NewReaderLabel
	if err = decoder.Decode(&mitreCve); err != nil {
		return nil, fmt.Errorf("Failed to Unmarshal XML. URL: %s, err: %s", url, err)
	}
	for _, vuln := range mitreCve.Vulnerability {
		for _, ref := range vuln.References {
			if strings.HasPrefix(ref.URL, "https://www.exploit-db.com/exploits/") {
				eid := strings.TrimSuffix(strings.TrimPrefix(ref.URL, "https://www.exploit-db.com/exploits/"), "/")
				eidCveMap[eid] = append(eidCveMap[eid], vuln.CVE)
				continue
			}

			ss := strings.Split(ref.Description, ":")
			if len(ss) != 2 {
				continue
			}
			refType, exploitID := ss[0], ss[1]
			// https://cve.mitre.org/data/refs/index.html
			if refType != "EXPLOIT-DB" {
				continue
			}
			eidCveMap[exploitID] = append(eidCveMap[exploitID], vuln.CVE)
		}
	}

	return eidCveMap, nil
}

// FetchExploitShellCodeMap :
func FetchExploitShellCodeMap() (eidShellCodeMap map[string]models.ShellCode, err error) {
	eidShellCodeMap = map[string]models.ShellCode{}
	url := "https://raw.githubusercontent.com/offensive-security/exploitdb/master/files_shellcodes.csv"
	log15.Info("Fetching", "URL", url)
	cveCsv, err := util.FetchURL(url)
	if err != nil {
		return nil, err
	}
	shellCodes := []models.ShellCode{}
	if err := gocsv.UnmarshalBytes(cveCsv, &shellCodes); err != nil {
		return nil, err
	}

	for _, shellCode := range shellCodes {
		shellCode.ShellCodeURL = "https://github.com/offensive-security/exploitdb/blob/master/" + shellCode.ShellCodeURL
		eidShellCodeMap[shellCode.ExploitUniqueID] = shellCode
	}
	return eidShellCodeMap, nil
}

// FetchExploitDocumentMap :
func FetchExploitDocumentMap() (eidDocMap map[string]models.Document, err error) {
	eidDocMap = map[string]models.Document{}
	url := "https://raw.githubusercontent.com/offensive-security/exploitdb/master/files_exploits.csv"
	log15.Info("Fetching", "URL", url)
	cveCsv, err := util.FetchURL(url)
	if err != nil {
		return nil, err
	}
	docs := []models.Document{}
	if err := gocsv.UnmarshalBytes(cveCsv, &docs); err != nil {
		return nil, err
	}

	for _, doc := range docs {
		doc.DocumentURL = "https://github.com/offensive-security/exploitdb/blob/master/" + doc.DocumentURL
		eidDocMap[doc.ExploitUniqueID] = doc
	}
	return eidDocMap, nil
}

// FetchExploitPaperMap :
func FetchExploitPaperMap() (eidPaperMap map[string]models.Paper, err error) {
	eidPaperMap = map[string]models.Paper{}
	url := "https://raw.githubusercontent.com/offensive-security/exploitdb-papers/master/files_papers.csv"
	log15.Info("Fetching", "URL", url)
	cveCsv, err := util.FetchURL(url)
	if err != nil {
		return nil, err
	}
	papers := []models.Paper{}
	if err := gocsv.UnmarshalBytes(cveCsv, &papers); err != nil {
		return nil, err
	}

	for _, paper := range papers {
		paper.PaperURL = "https://github.com/offensive-security/exploitdb-papers/blob/master/" + paper.PaperURL
		eidPaperMap[paper.ExploitUniqueID] = paper
	}
	return eidPaperMap, nil
}
