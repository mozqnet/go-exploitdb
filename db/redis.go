package db

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"
	"time"

	"github.com/cheggaaa/pb/v3"
	"github.com/go-redis/redis/v8"
	"github.com/inconshreveable/log15"
	"github.com/spf13/viper"
	"github.com/vulsio/go-exploitdb/config"
	"github.com/vulsio/go-exploitdb/models"
	"golang.org/x/xerrors"
)

/**
# Redis Data Structure

- Sets
  ┌───┬────────────────────────┬────────────────┬────────────────────────────────┐
  │NO │         KEY            │     MEMBER     │            PURPOSE             │
  └───┴────────────────────────┴────────────────┴────────────────────────────────┘
  ┌───┬────────────────────────┬────────────────┬────────────────────────────────┐
  │ 1 │ EXPLOIT#E#$EXPLOITDBID │ $EXPLOIT JSON  │ TO GET EXPLOIT FROM EXPLOITDBID│
  ├───┼────────────────────────┼────────────────┼────────────────────────────────┤
  │ 2 │ EXPLOIT#C#$CVEID       │ $EXPLOIT JSON  │ TO GET EXPLOIT FROM CVEID      │
  └───┴────────────────────────┴────────────────┴────────────────────────────────┘

- Hash
  ┌───┬───────────────────┬───────────────┬────────┬────────────────────────────────┐
  │NO │    KEY            │   FIELD       │  VALUE │       PURPOSE                  │
  └───┴───────────────────┴───────────────┴────────┴────────────────────────────────┘
  ┌───────────────────────┬───────────────┬────────┬────────────────────────────────┐
  │ 1 │ EXPLOIT#FETCHMETA │   Revision    │ string │ GET Go-Exploit Binary Revision │
  ├───┼───────────────────┼───────────────┼────────┼────────────────────────────────┤
  │ 2 │ EXPLOIT#FETCHMETA │ SchemaVersion │  uint  │ GET Go-Exploit Schema Version  │
  └───┴───────────────────┴───────────────┴────────┴────────────────────────────────┘
**/

const (
	dialectRedis      = "redis"
	exploitDBIDPrefix = "EXPLOIT#E#"
	cveIDPrefix       = "EXPLOIT#C#"
	fetchMetaKey      = "EXPLOIT#FETCHMETA"
)

// RedisDriver is Driver for Redis
type RedisDriver struct {
	name string
	conn *redis.Client
}

// Name return db name
func (r *RedisDriver) Name() string {
	return r.name
}

// OpenDB opens Database
func (r *RedisDriver) OpenDB(dbType, dbPath string, debugSQL bool) (locked bool, err error) {
	if err = r.connectRedis(dbPath); err != nil {
		err = fmt.Errorf("Failed to open DB. dbtype: %s, dbpath: %s, err: %s", dbType, dbPath, err)
	}
	return
}

// CloseDB close Database
func (r *RedisDriver) CloseDB() (err error) {
	if r.conn == nil {
		return
	}
	if err = r.conn.Close(); err != nil {
		return xerrors.Errorf("Failed to close DB. Type: %s. err: %w", r.name, err)
	}
	return
}

func (r *RedisDriver) connectRedis(dbPath string) error {
	var err error
	var option *redis.Options
	if option, err = redis.ParseURL(dbPath); err != nil {
		log15.Error("Failed to parse url.", "err", err)
		return err
	}
	ctx := context.Background()
	r.conn = redis.NewClient(option)
	err = r.conn.Ping(ctx).Err()
	return err
}

// MigrateDB migrates Database
func (r *RedisDriver) MigrateDB() error {
	return nil
}

// GetExploitByCveID :
func (r *RedisDriver) GetExploitByCveID(cveID string) []models.Exploit {
	ctx := context.Background()
	results, err := r.conn.SMembers(ctx, cveIDPrefix+cveID).Result()
	if err != nil {
		log15.Error("Failed to get exploit.", "err", err)
		return nil
	}

	exploits := []models.Exploit{}
	for _, result := range results {
		var exploit models.Exploit
		if err := json.Unmarshal([]byte(result), &exploit); err != nil {
			log15.Error("Failed to Unmarshal json.", "err", err)
			return nil
		}

		exploits = append(exploits, exploit)
	}
	return exploits
}

// GetExploitByID :
func (r *RedisDriver) GetExploitByID(exploitDBID string) []models.Exploit {
	ctx := context.Background()
	results, err := r.conn.SMembers(ctx, exploitDBIDPrefix+exploitDBID).Result()
	if err != nil {
		log15.Error("Failed to get exploit.", "err", err)
		return nil
	}

	exploits := []models.Exploit{}
	for _, result := range results {
		var exploit models.Exploit
		if err := json.Unmarshal([]byte(result), &exploit); err != nil {
			log15.Error("Failed to Unmarshal json.", "err", err)
			return nil
		}

		exploits = append(exploits, exploit)
	}
	return exploits
}

// GetExploitAll :
func (r *RedisDriver) GetExploitAll() []models.Exploit {
	ctx := context.Background()

	keys, err := r.conn.Keys(ctx, exploitDBIDPrefix+"*").Result()
	if err != nil {
		log15.Error("Failed to Keys.", "err", err)
		return nil
	}

	rs := []*redis.StringSliceCmd{}
	pipe := r.conn.Pipeline()
	for _, key := range keys {
		rs = append(rs, pipe.SMembers(ctx, key))
	}
	if _, err := pipe.Exec(ctx); err != nil {
		if err != redis.Nil {
			log15.Error("Failed to get multi exploit json.", "err", err)
			return nil
		}
	}

	exploits := []models.Exploit{}
	for _, result := range rs {
		vals, err := result.Result()
		if err != nil {
			log15.Error("Failed to Get Explit", "err", err)
			return nil
		}

		for _, val := range vals {
			var exploit models.Exploit
			if err := json.Unmarshal([]byte(val), &exploit); err != nil {
				log15.Error("Failed to Unmarshal json.", "err", err)
				return nil
			}
			exploits = append(exploits, exploit)
		}
	}

	return exploits
}

// GetExploitMultiByCveID :
func (r *RedisDriver) GetExploitMultiByCveID(cveIDs []string) (exploitsMap map[string][]models.Exploit) {
	ctx := context.Background()

	rs := map[string]*redis.StringSliceCmd{}
	pipe := r.conn.Pipeline()
	for _, cveID := range cveIDs {
		rs[cveID] = pipe.SMembers(ctx, cveIDPrefix+cveID)
	}
	if _, err := pipe.Exec(ctx); err != nil {
		if err != redis.Nil {
			log15.Error("Failed to get multi exploit json.", "err", err)
			return nil
		}
	}

	exploitsMap = map[string][]models.Exploit{}
	for cveID, results := range rs {
		vals, err := results.Result()
		if err != nil {
			log15.Error("Failed to Get Explit", "err", err)
			return nil
		}

		var exploits []models.Exploit
		for _, val := range vals {
			var exploit models.Exploit
			if err := json.Unmarshal([]byte(val), &exploit); err != nil {
				log15.Error("Failed to Unmarshal json.", "err", err)
				return nil
			}
			exploits = append(exploits, exploit)
		}
		exploitsMap[cveID] = exploits
	}
	return exploitsMap
}

//InsertExploit :
func (r *RedisDriver) InsertExploit(_ models.ExploitType, exploits []models.Exploit) (err error) {
	ctx := context.Background()
	expire := viper.GetUint("expire")
	batchSize := viper.GetInt("batch-size")
	if batchSize < 1 {
		return fmt.Errorf("Failed to set batch-size. err: batch-size option is not set properly")
	}

	bar := pb.StartNew(len(exploits))
	var noCveIDExploitCount, cveIDExploitCount int
	for idx := range chunkSlice(len(exploits), batchSize) {
		pipe := r.conn.Pipeline()
		for _, exploit := range exploits[idx.From:idx.To] {
			j, err := json.Marshal(exploit)
			if err != nil {
				return fmt.Errorf("Failed to marshal json. err: %s", err)
			}

			if 0 < len(exploit.CveID) {
				key := cveIDPrefix + exploit.CveID
				if result := pipe.SAdd(ctx, key, string(j)); result.Err() != nil {
					return fmt.Errorf("Failed to HSet CVE. err: %s", result.Err())
				}
				if expire > 0 {
					if err := pipe.Expire(ctx, key, time.Duration(expire*uint(time.Second))).Err(); err != nil {
						return fmt.Errorf("Failed to set Expire to Key. err: %s", err)
					}
				} else {
					if err := pipe.Persist(ctx, key).Err(); err != nil {
						return fmt.Errorf("Failed to remove the existing timeout on Key. err: %s", err)
					}
				}
				cveIDExploitCount++
			} else {
				noCveIDExploitCount++
			}

			key := exploitDBIDPrefix + exploit.ExploitUniqueID
			if result := pipe.SAdd(ctx, key, string(j)); result.Err() != nil {
				return fmt.Errorf("Failed to HSet Exploit. err: %s", result.Err())
			}
			if expire > 0 {
				if err := pipe.Expire(ctx, key, time.Duration(expire*uint(time.Second))).Err(); err != nil {
					return fmt.Errorf("Failed to set Expire to Key. err: %s", err)
				}
			} else {
				if err := pipe.Persist(ctx, key).Err(); err != nil {
					return fmt.Errorf("Failed to remove the existing timeout on Key. err: %s", err)
				}
			}
		}
		if _, err = pipe.Exec(ctx); err != nil {
			return fmt.Errorf("Failed to exec pipeline. err: %s", err)
		}
		bar.Add(idx.To - idx.From)
	}
	bar.Finish()
	log15.Info("No CveID Exploit Count", "count", noCveIDExploitCount)
	log15.Info("CveID Exploit Count", "count", cveIDExploitCount)
	return nil
}

// IsExploitModelV1 determines if the DB was created at the time of go-exploitdb Model v1
func (r *RedisDriver) IsExploitModelV1() (bool, error) {
	ctx := context.Background()

	exists, err := r.conn.Exists(ctx, fetchMetaKey).Result()
	if err != nil {
		return false, fmt.Errorf("Failed to Exists. err: %s", err)
	}
	if exists == 0 {
		key, err := r.conn.RandomKey(ctx).Result()
		if err != nil {
			if err == redis.Nil {
				return false, nil
			}
			return false, fmt.Errorf("Failed to RandomKey. err: %s", err)
		}
		if key != "" {
			return true, nil
		}
	}

	return false, nil
}

// GetFetchMeta get FetchMeta from Database
func (r *RedisDriver) GetFetchMeta() (*models.FetchMeta, error) {
	ctx := context.Background()

	exists, err := r.conn.Exists(ctx, fetchMetaKey).Result()
	if err != nil {
		return nil, fmt.Errorf("Failed to Exists. err: %s", err)
	}
	if exists == 0 {
		return &models.FetchMeta{ExploitRevision: config.Revision, SchemaVersion: models.LatestSchemaVersion}, nil
	}

	revision, err := r.conn.HGet(ctx, fetchMetaKey, "Revision").Result()
	if err != nil {
		return nil, fmt.Errorf("Failed to HGet Revision. err: %s", err)
	}

	verstr, err := r.conn.HGet(ctx, fetchMetaKey, "SchemaVersion").Result()
	if err != nil {
		return nil, fmt.Errorf("Failed to HGet SchemaVersion. err: %s", err)
	}
	version, err := strconv.ParseUint(verstr, 10, 8)
	if err != nil {
		return nil, fmt.Errorf("Failed to ParseUint. err: %s", err)
	}

	return &models.FetchMeta{ExploitRevision: revision, SchemaVersion: uint(version)}, nil
}

// UpsertFetchMeta upsert FetchMeta to Database
func (r *RedisDriver) UpsertFetchMeta(fetchMeta *models.FetchMeta) error {
	return r.conn.HSet(context.Background(), fetchMetaKey, map[string]interface{}{"Revision": fetchMeta.ExploitRevision, "SchemaVersion": fetchMeta.SchemaVersion}).Err()
}
